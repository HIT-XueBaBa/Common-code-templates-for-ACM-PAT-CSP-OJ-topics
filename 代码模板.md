以下代码模板是我在刷题过程中总结的比较常用的代码，大部分代码是我自己编写的**基于C++11语法的C++接口**，所以比较符合我自己的代码风格，解释和注释也不是很多。写这篇博客主要是做一下总结，以便自己以后使用，以后也会经常更新和修正。当然了，如果你觉得有些代码对你自己也有用处，也可以直接拿去使用，不过如果你不太习惯我的代码风格，使用起来可能会有些麻烦。如果有问题或者感觉我的代码中有bug，可以在下方评论区中留言哦ღ( ´･ᴗ･` )比心
# 数学
## 进制转换
### 把R进制字符串s转换成十进制数
```cpp
int strToDemical(const string&s,int R=10){
    int n=0;
    for(char c:s)
        n=n*R+(c-'0');
    return n;
}
```
### 把十进制数m转换成R进制数组z
```cpp
int demicalToR(int m,int z[],int R=10){
    int num=0;
    do{
        z[num++]=m%R;
        m/=R;
    }while(m!=0);
    reverse(z,z+num);
    return num;
}
```
## 欧几里得算法求两数a,b的最大公约数
```cpp
int gcd(int a,int b){
    return b==0?a:gcd(b,a%b);
}
```
## 分数
储存分数的结构体定义如下：
```cpp
struct F{
    int son,mother;//分子,分母
    F(int s,int m):son(s),mother(m) {}
};
```
### 将分数化简为最简分数
```cpp
void simplify(F&f){
    if(f.son==0){//分子为0，分母均变为1
        f.mother=1;
        return;
    }
    if(f.mother<0){//把分母上的负号移到分子上
        f.son=-f.son;
        f.mother=-f.mother;
    }
    int d=gcd(abs(f.son),f.mother);//求分子分母最大公约数
    f.son/=d;
    f.mother/=d;
}
```
### 分数输出
```cpp
void output(Fraction&f){
    if(f.mother==1)
        printf("%d",f.son);
    else{
        if(abs(f.son)<f.mother)
            printf("%d/%d",f.son,f.mother);
        else
            printf("%d %d/%d",f.son/f.mother,abs(f.son)%f.mother,f.mother);
    }
}
```
## 埃氏筛法求解n以内的素数表
```cpp
vector<int>prime;//素数表存储在prime中，prime是全局变量
void findPrime(int n){
    vector<bool>f(n,false);
    for(int i=2;i<n;++i)
        if(!f[i]){
            prime.push_back(i);
            for(int j=i+i;j<n;j+=i)
                f[j]=true;
        }
}
```
## 将数n质因子分解
```cpp
map<int,int>factor;//质因子在factor中，键表示质因子，值表示该质因子个数，注意map会按键排序
void getFactor(int n){
    if(n==1){
        factor[1]=1;
        return;
    }
    findPrime(n+1);//打印n+1以内的素数表存储到prime中
    for(int i:prime){
        while(n%i==0){
            ++factor[i];
            n/=i;
        }
        if(n==1)
            break;
    }
}
```
 # 日期处理
 ```cpp
 //周日用数字0表示
 int monthdays[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};//平年时每个月有多少天
int daysOfMonth(int y,int m){//判断y年m月有几天
    if((y%400==0||y%4==0&&y%100!=0)&&m==2)//y年是闰年且查询2月有几天
        return 29;//闰年2月有29天
    return monthdays[m];//直接返回monthdays的相应位置的天数
}
int determineWeek(int y,int m,int d,int week=2){//根据1850年1月1日是周二，返回y年m月d日是周几
    for(int i=1850;i<y;++i){//检查1850年到y年经历的年份
        int temp=(i%400==0||i%4==0&&i%100!=0)?366:365;//平年有365天，闰年有366天
        week=(week+temp)%7;//更新week
    }
    for(int i=1;i<m;++i)//检查1月到m月的月份
        week=(week+daysOfMonth(y,i))%7;//求出该月有几天，并更新week
    return (week+d-1)%7;//返回周几，注意周日用0表示
}
int determineDayOfNumberWeek(int y,int m,int b,int c){//判断y年m月第b个星期c是几号
    int week=determineWeek(y,m,1);//确定y年m月1日是周几
    return 1+(c+7-week)%7+7*(b-1);
}
 ```
# 高效算法
## 二分查找
### 在有序序列v中查找某数k的位置，二分区间为左闭右闭的区间[left,right]
```cpp
int binarySearch(vector<int>&v,int left,int right,int value){
    int mid;
    while(left<=right){
        mid=(left+right)/2;
        if(v[mid]==value)
            return mid;
        else if(v[mid]<value)
            left=mid+1;
        else
            right=mid-1;
    }
    return -1;
}
```
### 寻找有序序列中第一个满足某条件的位置，二分区间为左闭右闭的区间[left,right]
```cpp
int solve(vector<int>&v,int left,int right){
    int mid;
    while(left<right){
        mid==left+(right-left)/2;
        if(条件成立)
            right=mid;
        else
            left=mid+1;
    }
    return left;
}
```
## KMP算法
```cpp
void getNext(string pattern,int*next){
    int j=-1;
    next[0]=-1;
    for(int i=1;i<pattern.size();++i){
        while(j!=-1&&pattern[i]!=pattern[j+1])
            j=next[j];
        if(pattern[i]==pattern[j+1])
            ++j;
        next[i]=j;
    }
}
bool KMP(string text,string pattern){
    int next[pattern.size()];
    getNextval(pattern,next);
    for(int i:next)
        printf("%d ",i);
    int j=-1;
    for(int i=0;i<text.size();++i){
        while(j!=-1&&text[i]!=pattern[j+1])
            j=next[j];
        if(text[i]==pattern[j+1])
            ++j;
        if(j==pattern.size()-1)
            return true;
    }
    return false;
}
void getNextval(string pattern,int*next){
    int j=-1;
    next[0]=-1;
    for(int i=1;i<pattern.size();++i){
        if(j!=-1&&pattern[i]!=pattern[j+1])
            j=next[j];
        if(pattern[i]==pattern[j+1])
            ++j;
        if(j==-1||pattern[i+1]!=pattern[j+1])
            next[i]=j;
        else
            next[i]=next[j];
    }
}
int KMPcount(string text,string pattern){
    int next[pattern.size()];
    getNextval(pattern,next);
    for(int i:next)
        printf("%d ",i);
    int j=-1,result=0;
    for(int i=0;i<text.size();++i){
        while(j!=-1&&text[i]!=pattern[j+1])
            j=next[j];
        if(text[i]==pattern[j+1])
            ++j;
        if(j==pattern.size()-1){
            ++result;
            j=next[j];
        }
    }
    return result;
}
```
# 并查集
```cpp
int father[MAX];
void init(int n){//初始化并查集
    iota(father,father+n,0);
}
int findFather(int x){//寻找根结点并进行路径压缩
    if(x==father[x])
        return x;
    int temp=findFather(father[x]);
    father[x]=temp;
    return temp;
}
void unionSet(int a,int b){//合并两个集合
    int ua=findFather(a),ub=findFather(b);
    if(ua!=ub)
        father[ua]=ub;
}
int countRoot(int n){//求出并查集中有几个集合
    int num=0;
    for(int i=0;i<n;++i)
        if(father[i]==i)
            ++num;
    return num;
}
```
# 图
当涉及到的边除了首尾结点外还需要有其他信息，例如是否已被访问、该边的权值等时，采取如下方法存储图：
```cpp
struct Edge{//存储边的结构体
    int from,to;//首尾结点
    int cap,flow;//该边的容量、残量（最大流算法使用）
    bool visit;//欧拉序列使用
    int cost;//最短路问题使用
    ······
    Edge(int f,int t,······):from(f),to(t),cap(c),flow(fl) {}
};
vector<Edge>edges;//存储所有边
vector<int>graph[MAX];//graph[i][j]表示i号结点的第j条边在edges数组中的序号
```
注意，如果是无向图，则把一条边及其反向边相邻存储，则当已知一条边在edges数组中的序号为`i`时，其反向边在edges数组中的序号为`i^1`
## 拓扑排序
拓扑排序除首尾结点外，边不包含其他信息，不需要使用上面的存储结构，`graph[i]`中存储的直接是`i`号结点能到达的结点编号
```cpp
bool topSort(vector<int>&top){//degree存储各节点的入度
    queue<int>q;//储存入度为零的结点
    for(int i=0;i<=MAX;++i)//将入度为零的结点放入队列中
        if(degree[i]==0)
            q.push(i);
    while(!q.empty()){//队列不空
        int p=q.front();//弹出队首结点
        q.pop();
        top.push_back(p);
        for(int i:graph[p])//遍历该结点能到达的结点
            if(--degree[i]==0)//减少能到达结点的入度，如果入度为零
                q.push(i);//压入队列
    }
    return top.size()==MAX;
}
```
## 最短路径问题
### 针对无权图单源最短路的BFS算法
无权图单源最短路的BFS算法的边除首尾结点外，边不包含其他信息，不需要使用上面的存储结构，`graph[i]`中存储的直接是`i`号结点能到达的结点编号
```cpp
vector<int>graph[MAX];//graph[i][j]表示结点i能到达的第j个结点编号
bool BFS(int vstart,int vend){
    queue<int>q;
    bool inQueue[MAX]={false};
    q.push(vstart);
    inQueue[vstart]=true;
    while(!q.empty()){
        int p=q.front();
        q.pop();
        if(p==vend)
            return true;
        for(int i:graph[p]){
            if(!inQueue[i]){
                q.push(i);
                inQueue[i]=true;
            }
        }
    }
    return false;
}
```
### 针对正权图单源最短路的Dijkstra算法
```cpp
void Dijkstra(int vstart,int vend){  
    while(!visit[vend]){
        int MIN=INT_MAX,v=-1;  
        for(int i=0;i<N;++i){  
            if(!visit[i]&&dis[i]<MIN){  
                MIN=dis[i];  
                v=i;  
            }  
        }  
        if(v==-1)return;//v==-1表示是非连通图，直接返回  
        visit[v]=true;//标记为已访问  
        for(int i=0;i<graph[v].size();++i){  
            int temp=graph[v][i].v;  
            if(!visit[temp]&&dis[temp]>dis[v]+graph[v][i].length){  
                dis[temp]=dis[v]+graph[v][i].length;//更新最短路径长度  
            }
        }  
    }  
}
```
## 最小生成树问题
### Kruskal算法
```cpp
priority_queue<Edge>edges;//边的优先级队列
int father[MAX];
int findFather(int x){//查找父亲结点并进行路径压缩
    if(x==father[x])
        return x;
    int temp=findFather(father[x]);
    father[x]=temp;
    return temp;
}
int Kruskal(){//求解最小生成树的权值之和
	iota(father,father+MAX,0);//初始化并查集
    int sumCost=0; //sumCost表示整棵最小生成树的各边权值之和
    while(!edges.empty()){
        Edge e=edges.top();
        edges.pop();//弹出当前队列中边权最小的边
        int ua=findFather(e.from),ub=findFather(e.to);
        if(ua!=ub){
            sumCost+=e.cost;
            father[ua]=ub;
        }
    }
    return sumCost;//返回整棵树的权值之和
}
```
## 欧拉序列问题
存在欧拉路径的度数要求：
 - 对于无向图：不存在度数为奇数的结点，则存在欧拉回路，可以从任意结点出发；存在两个度数为奇数的结点，则存在欧拉环游，且必须从其中一个奇点出发，另一个奇点终止。
 - 对于有向图：不存在入度不等于出度的结点，则存在欧拉回路，可以从任意结点出发；存在两个入度不等于出度的结点，且一个点入度比出度小1，一个点入度比出度大1，则存在欧拉环游，且必须从入度比出度小1的结点出发，入度比出度大1的结点终止。

判断是否存在欧拉路径必须满足以下两个条件：
1. 图必须连通
2. 满足上述度数要求

求出欧拉序列可以用DFS算法实现，且在求出欧拉序列的同时可以判断图是否连通，代码如下：
```cpp
void DFS(int v){
    for(int i:graph[v]){
        if(!edges[i].visit){
            edges[i].visit=edges[i^1].visit=true;//有向图、无向图在这是不同的
            DFS(edges[i].to);
        }
    }
    ans.push_back(v);
}
```
**注意ans数组必须倒序输出才是正确的欧拉序列。假设有m条边，则判断图是否连通的语句是`ans.size()==m+1`**
## 最大流问题
### Edmonds-Karp算法
```cpp
int a[MAX],p[MAX];//a数组表示源点到结点a[i]的残量,p数组表示最短路树上到达结点p[i]的边在edges数组中的序号
int MaxFlow(int s,int t){//最大流算法,s为源点,t为汇点
    int flow=0;//最大流量
    while(true){
        memset(a,0,sizeof(a));//将源点到达每个结点的残量初始化为0
        //广度优先遍历查找从源点到达汇点的增广路
        queue<int>q;
        q.push(s);
        a[s]=INT_MAX;//起点的残量置为无穷大
        while(!q.empty()){
            int x=q.front();
            q.pop();
            for(int i:graph[x]){//遍历以x为起点的边
                Edge&e=edges[i];
                if(a[e.to]==0&&e.cap>e.flow){//当前边的终点的残量为0且容量大于流量
                    p[e.to]=i;//更新到达该终点的边的编号
                    a[e.to]=min(a[x],e.cap-e.flow);//更新源点到该终点的残量
                    q.push(e.to);//压入队列
                }
            }
            if(a[t]!=0)//终点的残量不为零，跳出循环
                break;
        }
        if(a[t]==0)//终点的残量为零，表示不存在增广路了，跳出外层死循环
            break;
        for(int u=t;u!=s;u=edges[p[u]].from){//从汇点向前遍历增广路经，更新每条增广路的流量
            edges[p[u]].flow+=a[t];
            edges[p[u]^1].flow-=a[t];
        }
        flow+=a[t];//增加最大流量
    }
    return flow;
}
```
